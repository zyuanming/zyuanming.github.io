---
layout: post
title: iOS Animation 学习（1）
date: 2014-09-01
categories: blog
tags: [iOS]
description: iOS Animation 学习（1）

---

动画是属性随着时间的可视化变化。不断变化的属性，可能是位置：东西移动或改变大小。其他种类的属性也是可以是动画的。例如，视图的背景颜色可以从红色变为绿色，不是瞬间的，而是从一个到另一个褪色的可视变化。或认为可能会从不透明变成透明的，也不是瞬间的，而是可视的渐行渐远。

如果没有帮助，我们大多数人会觉得动画遥不可及。有太多的并发问题 - 计算复杂，时机，屏幕刷新，线程，等等。幸运的是，帮助是有的。你不需要自己执行动画，你只需描述它，命令它，动画会为你执行。

要求执行动画可以很简单，比如设置一个属性值;在某些情况下，只需一行代码就可以执行动画：

    myLayer.backgroundColor = [UIColor redColor].CGColor; // animate to red
    

这并非巧合。苹果希望，你能够方便地使用动画。动画是IOS接口的关键特性。它不只是酷和有趣;它阐明了一些东西在改变或响应。例如，我的第一个应用程序是基于该用户点击卡片来选择其中一个OS X的游戏。在OS X版本，卡片被选中时会突出显示，并且当在不合格的卡片上点击时，电脑会发出哔哔声。在iOS上，这些指示是不够的：高亮不够明显、你不能在用户可能关闭音量或者是听音乐时用一个声音来警告。因此，在iOS版，用左右摆动的动画来显示卡片被选中，或者是全部颤抖来表示点击了不合格的卡片。（如果你正在为某些类型的游戏寻找创造一个完整的持续运行的动画世界，可以看看Sprite Kit，这是iOS 7提供的组件，这里不描述这个组件，但是可以让你更好地理解动画）。

* * *

## Drawing, Animation, and Threading

当您更改可视的视图属性，即使没有动画，这种变化也不会立刻显式地发生。相反，系统会记录这是一个你想作的改变，标志着视图需要重绘。您可以更改许多可见的视图属性，但这些变化仅仅构成一个积累起来的指令集。然后，当所有的代码已经完成运行，可以认为这时空闲，那么系统会重绘需要重画的所有视图，应用他们的新Visible属性。让我们把这个称为重绘时刻。

你可以简单地通过改变一些视图的可视属性，然后再改回来这种方式来验证这个重绘机制。同一个屏幕，一样的代码，但是什么都没有发生。例如，假设一个视图的背景颜色是绿色，你现在改变它的背景颜色为红色，然后又改回成绿色：

    // view starts out green
    view.backgroundColor = [UIColor redColor];
    // ... time-consuming code goes here ...
    view.backgroundColor = [UIColor greenColor];
    // code ends, redraw moment arrives
    

该系统积累的所有所需的更改，直到重绘一刻发生，并且重绘一刻不会发生直到你的代码已经完成，所以当重绘那一刻确实发生，在视图中的颜色，最后累积的变化是绿色 - 这就是它原来的颜色了。因此，不管有多少费时的代码位于从绿色到红色，红色到绿色的变化之间，用户都将看不到任何颜色的改变。

这就是为什么你不命令视图重绘;相反，你告诉它，它需要重绘 - setNeedsDisplay - 下一个重绘的时刻。这也是为什么有时候会使用 dispatch_after 来延迟执行某些代码，只是为了让重绘立刻发生。这种情况是很常见的。

同样，当要求一个动画执行时，动画不会立刻发生在屏幕上，而是直到下一次重绘时刻。（可以强制立即执行动画，但是这是不寻常的做法。）

现在让我们来谈谈这动画的执行机制。这都是一种巧妙的错觉。可以认为动画是用户和“真实”的画面之间的一种电影，卡通。而持续的动画，这部电影是叠加在屏幕上的。当动画结束之后，电影被除去，露出后面的“真正的”屏幕的状态。用户不知道这一切，因为（如果你已经做了正确的事情），在它启动的时候，影片的第一帧看起来就像在那一刻“真实”画面的状态，而在当时，它结束时，短片的最后一帧看起来就像“真实”的画面在那一刻的状态。

所以，当你通过动画从位置1，到位置2重新定位一个视图，你可以设想这样的典型事件序列：

1.  该视图被设置到位置2，但一直没有在重绘时刻，所以它仍描绘在位置1。

2.  代码的其余部分运行完成。

3.  重绘的时刻到来。如果没有动画，该视图现在将突然被放置在位置2，如果有一个动画，它（“动画电影”）在位置1中的视图开始，所以这仍然是用户所看到的。

4.  动画执行，绘制视图在位置1到位置2的中间位置，文档中称这段时间为动画的执行时。

5.  动画结束，绘制视图在最终的位置2。

6.  这个“动画电影”被移除，露出的视图的确是在位置2。

意识到这个“动画电影”与发生在实际视图上的是不同的，这样才能正确地配置一个动画。 对于初学者常常会抱怨： 为什么一个位置动画如预期执行了，但是，动画结束时，这个视图“跳到”了其它的位置。 这种情况发生的原因是，你设置了一个动画，但是没有移动视图，以匹配其在“动画电影”中的最终位置。当“电影”在动画结束时被移除时，视图实际的位置并没有与这个“电影”的最后一帧相匹配。

动画发生在一个独立的线程中。您不必担心细节（谢天谢地，因为多线程一般是相当棘手的），但你不能忽视它。你的代码可以与动画同时独立的执行 - 这就是多线程 - 所以你的代码可能需要规划一下与动画的通信。

当动画结束时通知你的代码，这个是很常见的需求。大多数的动画APIs 都会提供方法来设置一个通知（虽然在某些情况下，动画可能还没有真正结束，你仅仅假设收到通知时，动画结束了）。动画结束通知的一个用途可以用来进行链式动画，就是一个动画结束了，才执行下一个动画。另一个很平常的用途就是在处理触摸事件时进行清除： 当一个动画在执行时，而你的代码没有执行，界面默认会响应用户的触摸，这样可能会在你的视图试图在动画期间响应时发生各种不匹配的奇怪现象。为了防止这种情况，常用的方式是在设置一个动画时，关闭你的app对于触摸的响应，然后在收到动画结束通知时开启响应。

你也可以在一个动画执行期间，启动另一个动画，但是一定要注意不要产生冲突，一旦产生冲突，可能会把你之前的动画强制结束，这是你不希望的。 还有外部的力量也会让我们的动画停止，如用户点击home按钮，返回主界面，或者接到电话，这时系统默认的做法是简单地取消所有的动画，由于你在动画开始之前，已经设置视图为动画结束时的状态，因此这样做没有伤害。

* * *

## Presentation Layer

其实在屏幕前面并没有所谓的“动画电影”，尽管效果差不错。实际上，并不是layer 本身被绘制在屏幕上，而是一个派生layer，称为 展示层。 此外，当你以动画形式移动你的视图或者layer，从位置1到位置2，其名义上的位置会立刻改变，与此同时，展示层的位置仍然没有改变，直到重绘时刻，这就是用户实际看到的。

图层的表现层可以通过其presentationLayer属性来访问（而层本身就是表现层的modelLayer）。它的类型为id，所以为了用它来作为一个图层，你可能会想将它强制转换为CALayer *。访问presentationLayer是不常见的事情，但它可能会派上用场，如果你的代码需要知道正在执行的动画的当前状态。