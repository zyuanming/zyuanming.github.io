---
layout: post
title: OpenGL 知识点
date: 2019-11-22
categories: blog
tags: [图像处理]
description: 图像处理

---

### 顶点数组(VertexArray)和顶点缓冲区(VertexBuffer)

* OpenGL中的图像都是由图元组成。在OpenGLES中，有3种类型的图 元:点、线、三⻆角形。那这些顶点数据最终是存储在哪⾥的呢?开发者可以选择设定函数指针，在调⽤用绘制⽅方法的时候，直接由内存传⼊入顶点数据，也就是说这部分数据之前是存储在内存当中的，被称为顶点数组。⽽性能更高的做法是，提前分配一块显存，将顶点数据预先传⼊到显存当中。这部分的显存，就被称为顶点缓冲区。
* 顶点指的是我们在绘制一个图形时,它的顶点位置数据.而这个数据可以直接存储在数组中或者将其缓存到GPU内存中。

### 固定管线

固定管线也叫存储着色器。封装了一些写好的固定Shader程序，只需要传入给定参数，调用API，就可以完成基本的图形渲染，但这部分固定的Shader程序应用场景有限

### 可编程管线

相对上面来说，可以编写自己的着色器Shader程序，实现任意控制渲染。在OpenGL进行绘制的时候，首先由顶点着色器器对传⼊的顶点数据进行运算。再通过图元装配，将顶点转换为图元。然后进行光栅化，将图元这种⽮量图形，转换为栅格化数据。最后，将栅格化数据传入片段着⾊色器器中进行运算。片段着色器会对栅格化数据中的每一个像素进 行运算，并决定像素的颜⾊。


### 顶点着色器(VertexShader)

* 一个三角形，就会执行三次顶点着色器，每个顶点各执行一次，而且并行执行的，在顶点着色器运算过程中无法访问其它顶点数据。
* 一般用来处理图形每个顶点变换（旋转、平移、投影等）
* 这里还会发生顶点坐标由自身坐标系转换到归一化坐标系

### 片元着色器(FragmentShader)

* 一般处理每个像素点的颜色计算和填充
* 也是并行的，GPU负责这些海量并行计算


### 光栅化(Rasterization)

* 顶点数据描述了图形的形状，要想显示整个图形，还需要设置图形包围的区域的像素。光栅化就是把顶点数据转换为片元的过程，片元中每个元素对应帧缓冲区中的一个像素。
* 光栅化其实是一种将⼏何图元变为二维图像的过程。该过程包含了两部分的工作。第⼀部分⼯作: 决定窗⼝坐标中的哪些整型栅格区域被基本图元占用;第二部分工作: 分配⼀个颜⾊色值和⼀个深度值到各个区域。光栅化过程产生的是⽚元。
* 把物体的数学描述以及与物体相关的颜色信息转换为屏幕上⽤于对应位置的像素及用于填充像素的颜色，这个过程称为光栅化，这是一个将模拟信号转化为离散信号的过程

### 纹理

可以理解为位图

### 混合(Blending)

一般发生在重叠图形的颜色有透明度的时候。

### 渲染上屏/交换缓冲区(SwapBuffer)

* 渲染缓冲区⼀般映射的是系统的资源比如窗口。如果将图像直接渲染到窗口对应的渲染缓冲区，则可以将图像显示到屏幕上。
* 如果每个窗⼝只有一个缓冲区，那么在绘制过程中屏幕进⾏了刷新，窗⼝可能显示出不完整的图像。为了解决这个问题，常规的OpenGL程序⾄少都会有两个缓冲区。显示在屏幕上的称为屏幕缓冲区，没有显示的称为离屏缓冲区。在一个缓冲区渲染完成之后，通过将屏幕缓冲区和离屏缓冲区交换，实现图像在屏幕上的显示。
* 由于显示器器的刷新一般是逐行进行的，因此为了防⽌交换缓冲区的时候屏幕上下区域的图像分属于两个不同的帧，因此交换一般会等待显示器刷新完成的信号，在显示器两次刷新的间隔中进行交换，这个信号就被称为垂直同步信号，这个技术被称为垂直同步
* 使⽤了双缓冲区和垂直同步技术之后，由于总是要等待缓冲区交换之后再进⾏下⼀帧的渲染，使得帧率无法完全达到硬件允许的最高⽔平。为了解决这个问题，引⼊了三缓冲区技术，在等待垂直同步时，来回交替渲染两个离屏的缓冲区，⽽垂直同步发⽣时，屏幕缓冲区和最近渲染完成的离屏缓冲区交换，实现充分利⽤硬件性能的目的

### 绘制

* 图片的解码是CPU做的
* OpenGL ES 只有点、线、三角形
* 油画算法

    先绘制场景中离观察者较远的物体,再绘制较近的物体。如果三个三角形是叠加的情况,油画算法将无法处理。

    <div align = center>

    ![](/assets/images/2019/11-22-1.png)

    </div>
* 使⽤用正面/背面剔除法和深度测试法来解决渲染效率问题。

<div align = center>

![](/assets/images/2019/11-23-rendering-pipeline.png)

</div>

上图的多个顶点组成的重叠三角形，我们只需要设置每个顶点的颜色值，OpenGL可以自动帮我们把内部的颜色自动插值。


### 深度缓冲区

* 什什么是深度? 
    
    深度其实就是该像素点在3D世界中距离摄像机的距离,Z值

* 什么是深度缓冲区? 

    深度缓存区,就是一块内存区域,专⻔存储着每个像素点(绘制在屏幕上的)深度值.深度值(Z值)越⼤, 则离摄像机就越远.

* 为什么需要深度缓冲区? 

    在不使用深度测试的时候,如果我们先绘制⼀个距离⽐较近的物体,再绘制距离较远的物体,则距离远的位图因为后绘制,会把距离近的物体覆盖掉. 有了深度缓冲区后,绘制物体的顺序就不那么重要了. 实际上,只要存在深度缓冲区,OpenGL 都会把像素的深度值写⼊到缓冲区中. 除非调⽤ `glDepthMask(GL_FALSE)` 来禁止写⼊.

* 什么是深度测试？

    深度缓冲区(DepthBuffer)和颜⾊色缓存区(ColorBuffer)是对应的.颜⾊缓存区存储像素的颜⾊信息,⽽深度缓冲区存储像素的深度信息. 在决定是否绘制⼀个物体表⾯时, 首先要将表⾯对应的像素的深度值与当前深度缓冲区中的值进⾏⽐较. 如果大于深度缓冲区中的值,则丢弃这部分.否则利⽤这个像素对应的深度值和颜⾊值.分别更新深度缓冲区和颜⾊缓存区. 这个过程称为”深度测试”

    深度是以像素为单位，而不是以顶点为单位。

## 参考网址

* [http://web.cse.ohio-state.edu/~shen.94/781/Site/Slides_files/pipeline.pdf]()