---
layout: post
title: OpenGL 图元绘制
date: 2019-11-24
categories: blog
tags: [图像处理]
description: 图像处理

---


本文是[斯坦福大学2010年（CS193P）OpenGL](https://youtu.be/_WcMe4Yj0NM)课的一个总结。参考源代码已上传到[GitHub](https://github.com/zyuanming/OpenGLTransform)。

## 归一化设备坐标 到 窗口坐标

* 归一化设备坐标（normalized device coordinates）：表示范围是[-1,1]
* 窗口坐标（window coordinates）：原点是左下角

```
void glViewport(GLint x,
                GLint y,
                GLsizei width,
                GLsizei height);

```

glViewport 这个函数指定了x和y从归一化的设备坐标到窗口坐标的仿射变换。例如令$(x_{nd},y_{nd})$ 为归一化的设备坐标，$(x_w,y_w)$ 为窗口坐标，计算公式如下：

$$x_w=(x_{nd} + 1)\left(\frac{width}{2}\right) + x$$
$$y_w=(y_{nd} + 1)\left(\frac{height}{2}\right) + y$$

当

$$x_{nd} = 0$$
$$y_{nd} = 0$$
$$x = 0$$
$$y = 0$$

这时计算出窗口的原点坐标为

$$x_w = \frac{width}{2}$$
$$y_w = \frac{height}{2}$$

显然这是手机屏幕的中心点位置

```
// 设置视口大小为手机屏幕显示区域大小
glViewport(0, 0, backingWidth, backingHeight);
```
<div align = center>

![](/assets/images/2019/11-27-2.png)

</div>

```
// 高度减少一半
glViewport(0, 0, backingWidth, backingHeight / 2.0);
```
<div align = center>

![](/assets/images/2019/11-27-1.png)

</div>


## 观察坐标 到 裁剪坐标

* 观察坐标（View Coordinate）
* 裁剪坐标（Clip Coordinate）

将观察坐标变换为裁剪坐标的投影矩阵可以为两种不同的形式，每种形式都定义了不同的平截头体。
1. 正交投影矩阵(Orthographic Projection Matrix)

    一般用于2D转换

2. 透视投影矩阵(Perspective Projection Matrix)

    一般用于3D转换


### 1. 正交投影矩阵

```
// near 表示摄像头离物体距离少于near的，都裁剪掉
// far 表示摄像头离物体距离大于far的，都裁剪掉
void glOrthof(GLfloat left,
              GLfloat right,
              GLfloat bottom,
              GLfloat top,
              GLfloat near,
              GLfloat far);
```
前两个参数指定了平截头体的左右坐标，第三和第四参数指定了平截头体的底部和顶部。通过这四个参数我们定义了近平面和远平面的大小，然后第五和第六个参数则定义了近平面和远平面的距离。这个投影矩阵会将处于这些x，y，z值范围内的坐标变换为标准化设备坐标。


由于OpenGL内部是一个状态机，内部总会有一个活动的矩阵，来决定当前影响的是哪个变换，所以为了从观察坐标到裁剪坐标的转换，我们设置进入投影矩阵（Projection Matrix）模式，表明我们当前是操作投影矩阵：

```
// 表明当前矩阵指定了投影变换，接下来的转换调用将影响投影矩阵
glMatrixMode(GL_PROJECTION);
// 初始化当前投影矩阵，加载单位矩阵。
glLoadIdentity();
// 设置正交投影矩阵
glOrthof(-2, 2, -2, 2, -1, 1);
```

如下可以看到宽，高都变成了原来的一半了：
<div align = center>

![](/assets/images/2019/11-27-3.png)

</div>


```
glOrthof(-1, 1, -1, 1, -1, 1);
```
可以看到，这样的正交投影矩阵，出来的效果跟单位矩阵一样，没变化：
<div align = center>

![](/assets/images/2019/11-27-2.png)

</div>

```
glOrthof(0, 2, 0, 2, -1, 1);
```
可以看到，只显示了右上角部分，并缩小了一半：
<div align = center>

![](/assets/images/2019/11-27-4.png)

</div>


### 2. 透视投影矩阵

```
glMatrixMode(GL_PROJECTION);
glLoadIdentity();
// 设置透视投影矩阵
glFrustumf(-1, 1, -1, 1, 5, 10);

// 
glMatrixMode(GL_MODELVIEW);	
glLoadIdentity();
glTranslatef(0, 0, -7);
// 为了展示3D效果，沿y轴做了30度的旋转
static float k = 0.0;
k += 0.1;
glRotatef(30 * sinf(k), 0, 1, 0);
```
因为上面设置了相机距离物体少于5时裁剪掉物体，而物体默认z轴是0，表示相机与物体的距离为0，所以我们还需要切换到模型视图矩阵，将多维数据集从相机移开（通过模型视图矩阵转换）`glTranslatef`，而不是移动相机（使用视图变换矩阵）以便可以查看多维数据集。
<div align = center>

![](/assets/images/2019/11-27-6.gif)
</div>


如果我们在`glRotatef`之前调用`glTranslatef`，向右上角平移，注意，这里x，y都传了1。仔细看效果，发现图片的左下角移到了屏幕中心，而不是移动一个像素，这是矩阵运算的结果。
```
glTranslatef(1, 1, 0);
glRotatef(30 * sinf(k), 0, 1, 0);
```
<div align = center>

![](/assets/images/2019/11-27-7.gif)
</div>


但是如果在`glRotatef`之后才调用`glTranslatef`，效果就会非常不同，可以看到结果是绕图片左边旋转了。OpenGL的转换需要注意顺序。
```
glRotatef(30 * sinf(k), 0, 1, 0);
glTranslatef(1, 1, 0);
```
<div align = center>

![](/assets/images/2019/11-27-8.gif)
</div>


## 参考链接

* [glViewport](https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewport.xhtml)
* [Markdown 中 LaTex 数学公式命令](https://juejin.im/post/5c0a27ee6fb9a049d05d8b70)
* [Markdown+LaTex Math](https://ming-lian.github.io/2019/03/30/Markdown-LaTexMath/)
* [CS 193P - OpenGL ES](https://web.stanford.edu/class/cs193p/cgi-bin/drupal/node/79)