---
layout: post
title: 图像重采样算法之最邻近插值算法
date: 2020-01-29
categories: blog
tags: [图像处理]
description: 图像处理

---

## 概述

最近邻插值是最简单的插值方法。该方法不是根据某些加权标准来计算平均值，也不是根据复杂的规则生成中间值，而是根据目标图像的宽（高）与源图像的宽（高）比值，取源图像相对位置的像素点作为目标像素点的值。新的像素值一定是原图的某个像素值。

假设我们要把一个2X2的小图片拉伸到4X4的尺寸，如下所示

![](/assets/images/2020/nn1-1.png)

假设P1的坐标为(Dx, Dy)，原图的宽、高分别为Sw、Sh，拉伸后的图像宽、高分别为Dw、Dh，我们需要求P1在原图的坐标(Sx, Sy)。则

```
由 
    Dx / Dw = Sx / Sw
    Dy / Dh = Sy / Sh
得 
    Sx = Dx * (Sh / Dh)
    Sy = Dy * (Sw / Dw)
代入
    Dx = 0
    Dy = 0
    Sh = 2
    Sw = 2
    Dh = 4
    Dw = 4
得P1对应原图的坐标
    Sx = 0 * (2 / 4) = 0
    Sy = 0 * (2 / 4) = 0
同理P2的坐标为(0, 1)，代入
得P2对应原图的坐标
    Sx = 0 * (2 / 4) = 0
    Sy = 1 * (2 / 4) = 0.5 // 去掉小数部分 为 0
```
因此P1点对应原图的坐标为(0, 0)，也就是P1的值为10，P2对应原图的坐标为(0, 0)，因此P2的值也为10，以此类推

![](/assets/images/2020/nearest_neighbor.png)


## 算法实现

我在iOS平台上，使用Objective-C语言实现这个算法。首先需要获取到图片的RGBA数据，也叫RAW数据，这是一个一维数组，但是在实际处理中我们需要二维的数据。


1. 获取图片RGBA数据

```
UInt32* pixelData = (UInt32 *)calloc(width * height, sizeof(UInt32));
CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
CGContextRef context = CGBitmapContextCreate(pixelData,
                                                width,
                                                height,
                                                bitsPerComponent,
                                                bytesPerRow,
                                                colorSpace,
                                                kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);

CGContextDrawImage(context, CGRectMake(0, 0, width, height), cgOriginalImage);
```

2. 简单地循环遍历目标/输出图像中的所有像素，通过将宽、高坐标按`rowRatio`和`colRatio`缩放，并去掉小数得到缩放索引值，从而来寻址要复制的源像素

```
static UInt32* scaleImageWithNearesNeighborInterpolation(UInt32* pixelData, int sourceWidth, int sourceHeight, int desWidth, int desHeight) {
    
    // 宽和高的缩放常数
    float rowRatio = ((float)sourceHeight) / ((float)desHeight);
    float colRatio = ((float)sourceWidth) / ((float)desWidth);
    UInt32* rgba = (UInt32 *)calloc(desWidth * desHeight, sizeof(UInt32));
    int offset=0;
    for(int i = 0; i < desHeight; ++i) {
        // 如果用round则四舍五入，round(0.5) = 1
        // 这里用floor，floor(0.5) = 0
        int srcRow = floor(((float)i)*rowRatio);
        if(srcRow >= sourceHeight) {
            srcRow = sourceHeight - 1;
        }
        
        for (int j = 0; j < desWidth; j++) {
            
            int srcCol = floor(((float)j)*colRatio);
            if(srcCol >= sourceWidth) {
                srcCol = sourceWidth - 1;
            }
            
            rgba[offset]   = pixelData[(srcRow * sourceWidth + srcCol)];
            offset++;
        }
    }
    
    return rgba;
}
```

3. 把新的rgba数据，转换回UIImage

```
CGContextRef bitmapContext = CGBitmapContextCreate(
                                                    rgba,
                                                    width,
                                                    height,
                                                    bitsPerComponent,
                                                    bytesPerRow,
                                                    colorSpace,
                                                    kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);

CGImageRef cgImage = CGBitmapContextCreateImage(bitmapContext);
UIImage *newUIImage = [UIImage imageWithCGImage:cgImage];
```