---
layout: post
title: 图像重采样算法之最邻近插值算法
date: 2020-01-29
categories: blog
tags: [图像处理]
description: 图像处理

---

## 概述

最近邻插值是最简单的插值方法。该方法不是根据某些加权标准来计算平均值，也不是根据复杂的规则生成中间值，而是根据目标图像的宽（高）与源图像的宽（高）比值，取源图像相对位置的像素点作为目标像素点的值。新的像素值一定是原图的某个像素值。

假设我们要把一个2X2的小图片拉伸到4X4的尺寸，如下所示

![](/assets/images/2020/nn1-1.png)

对于P1点，显然与10的格子最近，因此P1为10，同理P2也为10，以此类推，得到下图

![](/assets/images/2020/nearest_neighbor.png)


假设P1的坐标为(Dx, Dy)，原图的宽、高分别为Sw、Sh，拉伸后的图像宽、高分别为Dw、Dh，我们需要求P1在原图的坐标(Sx, Sy)。则

```
由 
   Dx / Dw = Sx / Sw
   Dy / Dh = Sy / Sh
得 
   Sx = Dx * (Sh / Dh)
   Sy = Dy * (Sw / Dw)
```


## 关键代码

```
static char* scaleImageWithNearesNeighborInterpolation(char* pixelData, int sourceWidth, int sourceHeight, int desWidth, int desHeight) {
    
    // 计算行与列的缩放比例
    float rowRatio = ((float)sourceHeight) / ((float)desHeight);
    float colRatio = ((float)sourceWidth) / ((float)desWidth);
    char* rgba = (char*)malloc(desWidth * desHeight * 4);
    int offset=0;
    for(int i = 0; i < desHeight; ++i) {
        // 计算源像素点的行的位置
        int srcRow = round(((float)i)*rowRatio);
        if(srcRow >= sourceHeight) {
            srcRow = sourceHeight - 1;
        }
        
        for (int j = 0; j < desWidth; j++) {
            // 计算源像素点的列的位置
            int srcCol = round(((float)j)*colRatio);
            if(srcCol >= sourceWidth) {
                srcCol = sourceWidth - 1;
            }
            
            rgba[4*offset]   = pixelData[(srcRow * sourceWidth + srcCol) * 4];
            rgba[4*offset+1] = pixelData[(srcRow * sourceWidth + srcCol) * 4 + 1];
            rgba[4*offset+2] = pixelData[(srcRow * sourceWidth + srcCol) * 4 + 2];
            rgba[4*offset+3] = pixelData[(srcRow * sourceWidth + srcCol) * 4 + 3];
            offset++;
        }
    }
    
    return rgba;
}
```